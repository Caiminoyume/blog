---
slug: what-is-tls
title: TLS 技术鉴赏 —— 1. TLS 的基本原理
date: 2023-08-02 18:26:06
tags:
  - TLS
  - Network
  - Secure
categories: 
  - 技术鉴赏
  - TLS
math: true
summary: 真的会有第二篇吗（）
---
# 前言
最近一直在看关于网络通信的书，正好趁此博客刚刚开站，打算写一系列的文章。若是没人看，权当作笔记了吧。~~说不定几篇之后就没动力写了~~

其实网络通信可讲的太多，不过笔者认为，研究网络安全，在攻防角色间相互代换，可称为颇有一番乐趣的智力游戏。于是乎，第一篇的主题就定下来了

要讨论通信安全，那就不得不先谈密码学了，要达成安全的目的，必然与密码有千丝万缕的联系。不过本篇由于只讲基本原理，并不会对具体的密码算法有过多的讲解，针对下面要讲到的加密方式，将其理解为概念上完美的加密方式即可（即，在不知道密钥的前提下，绝无可能破译）

# 预备知识
### 对称加密算法
对称加密很好理解，即双方使用同样的密钥进行加密和解密。用数学的语言表述如下：

$$c=K(p)$$
$$K(c)=K(K(p))=p$$

上述式子中，$p$ 即明文（plaintext），$c$ 即密文（ciphertext），$K$ 即密钥（key），通过密钥对明文加密得到密钥

### 不对称加密算法
不对称加密具有一种特殊的性质，即它使用一个密钥对，私钥加密而公钥解密，公钥加密而私钥解密，公钥/私钥都无法对自己加密的内容解密
再一次，用数学的语言表达如下：

$$K^+(K^-(p))=p$$
$$K^-(K^+(p))=p$$

在数学上，密钥对实际没有区别，习惯上，我们将公开出去的密钥叫公钥（publickey），而自己持有的密钥叫私钥（privatekey），式子中，将公钥用 $K^+$ 表示，私钥用 $K^-$ 表示

* 由于不对称加密算法资源消耗大，实践中一般不直接用来加密报文，而是用来传递对称加密的密钥

### 哈希算法
虽然哈希算法不能叫加密算法，但它在验证原文的完整性时非常重要，也是通信安全中必不可少的一位，因此将它放在这里
哈希算法具有这些性质：
1. 对于任意报文 $m$，都能生成固定长度的字符串（哈希值） $H(m)$
2. 对于相同的报文 $m$，总是能生成相同的哈希值 $H(m)$
3. 找到任意两个不同的报文 $x$ 和 $y$，使 $H(x)=H(y)$，在计算上是不可能的

显然哈希算法的输入和输出不是一一对应的，必然会有相当多的报文 $m_1,m_2,\ldots$ 的哈希值相同（这种现象被称为**哈希碰撞**），只是我们无法在合理的时间内根据 $m_1$ 去计算其他和它哈希值相等的报文。这也正是第三条表达的意思

### 数字签名
数字签名是由哈希算法和不对称加密算法结合起来的产物。签名者将报文的哈希值用自己的私钥加密（该加密数据即为**数字签名**），并同报文一起发送给接受者。接受者使用公钥解密，并验证哈希值，即可知晓报文是否被篡改以及验证发送者的身份

### 一条加密隧道应该具有的性质
好了，有了上面这些的工具后，是时候考虑如何建立一条可靠的隧道了，这条隧道应该具有以下性质：
1. 机密性：密文无法被窃听者理解
2. 完整性：密文没有被恶意篡改
3. 端点鉴别：通信双方都要能证实另一方的身份

接下来开始头脑风暴！

# 如何创立可靠的加密信道
现在设想一台主机 $C$，它现在要去访问名叫 `www.example.com` 的服务器，开始构想一种方式使它与服务器的通信免受骇客的侵扰吧！

### 加密1.0：使用对称加密
主机 $C$ 运气很好，它一开始就和 `www.example.com` 拥有同样的（而且只有它们俩知道）对称加密密钥，那事情变得非常简单了，直接使用密钥加密就能保证安全

$$client\stackrel{K(p)}{\Longleftarrow==\Longrightarrow}server$$

但是这种情况是极其少见的，在很多情况下，主机 $C$ 可能是首次和 `www.example.com` 取得联系
并且由一方生成密钥并传输过去也是不行的，在公网上明文传输密钥是极可能被骇客截获，以后的通信就毫无安全可言了

### 加密2.0：使用不对称加密
那么使用不对称加密又如何呢？比如由服务器分发公钥（公钥是可以被任何人知道的），这样主机 $C$ 可以在本地生成对称加密的密钥 $k$，并使用公钥加密传递给服务器了

$$client\stackrel{K^+(k)}{===\Longrightarrow}server$$

很不幸，一个聪明的骇客拦截了服务器发往主机 $C$ 的公钥 $K_{s}^+$，并替换为自己的公钥 $K_{h}^+$，如此，密钥就能被骇客截获

$$client\stackrel{K_{h}^{+}(k)}{====\Longrightarrow}cracker\stackrel{K_{s}^{+}(k)}{====\Longrightarrow}server$$

### 加密3.0：引入 CA
实际上可以注意到，如果主机 $C$ 除对域名 `www.example.com` 外，对要访问的服务器一无所知的话，任何加密都是无法验证服务器身份的。就好比你声称要见一个叫“小明”的人，而完全不知道其声音、外貌等等，那么任何人都可以声称自己是“小明”来欺骗你

但在实际中，主机要去访问一个第一次知道的网站的情况十分常见，~~比如你现在多半也是第一次见到这个域名，进入笔者的博客~~

那么，一种自然的想法就是，既然你不可能认识世界上所有人，那么为了保证你见到的人就是“小明”，需要一个神通广大且可靠的朋友作为中介。而在计算机网络里，这个中介就是[CA](https://zh.wikipedia.org/zh-sg/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84)（数字证书认证机构，Certificate Authority）

#### CA 如何验证身份？
事实上是，当主机 C 要访问 `www.example.com` 时，并不会事先去联系 CA（想象一下全世界那么多主机每次访问网站前都要联系 CA 是多么可怕的事），而是由网站的服务器给出 CA 颁发的证书（digital certificate），这“张”证书包含以下数据：
* CA 机构的名称
* 服务器的域名
* 服务器公钥
* 证书的数字签名
* 证书的有效期
* 其他（主要是协议版本和加解密算法等等）

那么当主机 $C$ 收到这张证书时会干什么事呢？首先，它会使用证书上的对应 CA 的公钥解密数字签名并验证证书，确定证书的有效性后，提取服务器域名和公钥，后续就可以使用该公钥传递对称加密密钥建立加密信道了

但是这里似乎有个疑惑，CA 的公钥是从哪里来的呢？答案是，**内置**！在安装浏览器/操作系统时，会自带可信任的 CA 名称及其公钥，这样即可达成信任链，完成对证书的验证

* 由于 CA 机构的地位，某些流氓浏览器可能会内置一些不具有权威性的 CA，请勿使用除Edge，Chrome，Firefox等大厂以外的浏览器！
* 某些恶意软件取得操作系统管理员权限后，也可能安装信任一些不友好的证书！
* 一旦信任链一环出现问题，黑客就有可能做到窃听乃至劫持！

#### CA机构的风险
在上述过程中，不难察觉到 CA 的权力过于集中，不免引起人们的担忧：一旦 CA 作恶，后果不堪设想

CA 可能的风险：
1. [机构人员因某些原因（失误或腐败接受贿赂等）颁发伪造证书](https://security.googleblog.com/2015/10/sustaining-digital-certificate-security.html)
2. CA 遭受骇客入侵，伪造证书
3. CA 受政府压力，给予伪造证书（棱镜门事件中，美国政府可能强迫 CA 为他们颁发假证书）

关键是，一个中心化的机构总是无法避免此类情况的发生，人们无法完全相信一个集权的机构

### 加密4.0：CT制度
[CT](https://zh.wikipedia.org/zh-cn/%E8%AF%81%E4%B9%A6%E9%80%8F%E6%98%8E%E5%BA%A6)（证书透明，Certificate Transparency），通过将证书颁发等操作公开，受任何人监督，达到无法篡改和伪造证书的目的

# 结语
如此一来，一条加密信道就在理论上建立起来了

下面笔者可能（~~也可能没有，咕咕咕~~）会花几篇的文章详细讲解 TLS 的具体技术细节，通过预演可能遭到的攻击来梳理 TLS 各种设计的逻辑，敬请期待吧